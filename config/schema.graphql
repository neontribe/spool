schema {
  query: Query
  mutation: Mutations
}

type Consumer {
  creatorActivityCount(range: DateRangeInput): CreatorActivityCount
}

input CreateEntryInput {
  entry: EntryInput
  clientMutationId: String!
}

type CreateEntryPayload {
  viewer: Viewer
  entryEdge: EntryEdge
  clientMutationId: String!
}

input CreateRequestInput {
  request: RequestInput
  clientMutationId: String!
}

type CreateRequestPayload {
  viewer: Viewer
  clientMutationId: String!
}

type Creator {
  entries(after: String, first: Int, before: String, last: Int): EntryConnection
  requests(after: String, first: Int, before: String, last: Int): UserRequestConnection
  happyCount: Int
  sadCount: Int
}

type CreatorActivityCount {
  active: Int
  stale: Int
}

input DateRangeInput {
  from: String!
  to: String!
}

type Entry implements Node {
  # The ID of an object
  id: ID!
  _id: Int
  media: Media
  author: User
  owner: User
  sentiment: Sentiment
  topic: [Topic]
  timestamp: String
}

# A connection to a list of items.
type EntryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [EntryEdge]
}

# An edge in a connection.
type EntryEdge {
  # The item at the end of the edge
  node: Entry

  # A cursor for use in pagination
  cursor: String!
}

input EntryInput {
  media: MediaInput
  sentiment: String
  topic: [String]
}

type Media {
  text: String
  video: String
  videoThumbnail: String
  image: String
  imageThumbnail: String
}

input MediaInput {
  text: String
  video: String
  videoThumbnail: String
  image: String
  imageThumbnail: String
}

type Meta {
  regions: [String]
  roles: [RoleDefinition]
}

type Missing {
  information: [String]
}

type Mutations {
  createEntry(input: CreateEntryInput!): CreateEntryPayload
  createRequest(input: CreateRequestInput!): CreateRequestPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
}

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Query {
  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
  viewer: Viewer
  meta: Meta
}

type Request implements Node {
  # The ID of an object
  id: ID!
  _id: Int
  from: String
  to: String
  region: String
  user: User
}

input RequestInput {
  range: DateRangeInput
}

union Role = Creator | Consumer | Missing

type RoleDefinition {
  type: String
  name: String
  secret: String
}

type Sentiment {
  type: String
}

type Topic {
  type: String
  name: String
}

input UpdateUserInput {
  user: UserInput
  clientMutationId: String!
}

type UpdateUserPayload {
  viewer: Viewer
  clientMutationId: String!
}

type User {
  id: Int
}

input UserInput {
  region: String!
  roleSecret: String!
}

type UserRequest implements Node {
  # The ID of an object
  id: ID!
  _id: Int
  request: Request
  seen: Boolean
}

# A connection to a list of items.
type UserRequestConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [UserRequestEdge]
}

# An edge in a connection.
type UserRequestEdge {
  # The item at the end of the edge
  node: UserRequest

  # A cursor for use in pagination
  cursor: String!
}

type Viewer implements Node {
  # The ID of an object
  id: ID!
  role: Role
  region: String
  topics: [Topic]
}
